function [L,scrop] = laplacian_from_image(im,opt)
%function for generating a series of windowed graph laplacian
%from a givin image. L is formatted for the cbpdn_L code.  
%Format for L: L{i}.ind1, L{i}.ind2 L{i}.M (or L{i}.phi, L{i}.E)

%Format for opt:
%   opt.Lformat: 'Full', 'Sparse', 'Eig'
%   opt.Laplacian: 'n', 'u'
%   opt.Graph:
%           opt.Graph.tau
%           opt.Graph.Metric: 'Euclidean', 'Cosine'
%           opt.Graph.GraphType: 'Full', 'Window', 'WindowKNearest',
%                                   'SoftWindow'
%           opt.Graph.nsz
%           opt.Graph.coefsz (set by default here)
%           opt.Graph.k: number of k-nearest neighbors

imsz = size(im);
wsz = opt.wsz;
psz = opt.psz;

n1 =  floor(imsz(1)+1-psz(1)/wsz(1)); %number of windows in a col
n2 =  floor(imsz(2)+1-psz(2)/wsz(2)); %number of windows in a row
%coefsz = [n1*wsz(1), n2*wsz(2)];

iter = 1;
L = {};

for i = 1:n1
    for j = 1:n2
        ind1 = [(i-1)*wsz(1)+1,(j-1)*wsz(2)+1];
        ind2 = ind1 + wsz - [1,1];
        L{iter}.ind1 = ind1;
        L{iter}.ind2 = ind2;
        Ltemp = winlap( im, ind1, ind2, psz,opt);
        if strcmp(opt.Lformat, 'Full')
            L{iter}.M = Ltemp;
        end
        if strcmp(opt.Lformat, 'Sparse')
            L{iter}.M = sparse(Ltemp);
        end
        if strcmp(opt.Lformat, 'Eig')
            [V,E] = eigs(Ltemp,20,'sr');
            L{iter}.E = diag(E);
            L{iter}.phi = V;
        end
        iter = iter+1;        
    end
end



%cropped image that fits this windowing
scrop = im(1:coefsz(1), 1:coefsz(2));

end
